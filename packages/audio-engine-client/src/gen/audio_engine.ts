// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.10.1
//   protoc               v6.32.1
// source: audio_engine.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import type { CallContext, CallOptions } from "nice-grpc-common";

export const protobufPackage = "audio_engine";

export interface Track {
  trackId: number;
  queueName: string;
  description: string;
  audioRequestString: string;
  tapName: string;
  volume: number;
}

export interface GetSessionStateRequest {
  guildId: number;
}

export interface SessionState {
  guildId: number;
  channelId: number;
  tracks: Track[];
}

export interface SessionStateResponse {
  state?: SessionState | undefined;
  error?: Error | undefined;
}

export interface JoinRequest {
  guildId: number;
  channelId: number;
}

export interface LeaveRequest {
  guildId: number;
}

export interface AudioStopFilter {
  all?: AudioStopFilter_All | undefined;
  music?: AudioStopFilter_Music | undefined;
  tts?: AudioStopFilter_TTS | undefined;
}

export interface AudioStopFilter_All {
}

export interface AudioStopFilter_Music {
}

export interface AudioStopFilter_TTS {
  userId: number;
}

export interface Error {
  message: string;
  isInternal: boolean;
}

export interface OkResponse {
  success?: boolean | undefined;
  error?: Error | undefined;
}

export interface PlayRequest {
  guildId: number;
  queueName: string;
  tapName: string;
  audioRequestString: string;
  volume: number;
}

export interface PlayResponse {
  trackId?: number | undefined;
  error?: Error | undefined;
}

export interface SetVolumeRequest {
  guildId: number;
  trackId: number;
  volume: number;
}

export interface StopRequest {
  guildId: number;
  trackId: string;
}

export interface NextMusicRequest {
  guildId: number;
}

export interface StopManyRequest {
  guildId: number;
  filter: AudioStopFilter | undefined;
}

function createBaseTrack(): Track {
  return { trackId: 0, queueName: "", description: "", audioRequestString: "", tapName: "", volume: 0 };
}

export const Track: MessageFns<Track> = {
  encode(message: Track, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.trackId !== 0) {
      writer.uint32(8).uint64(message.trackId);
    }
    if (message.queueName !== "") {
      writer.uint32(18).string(message.queueName);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.audioRequestString !== "") {
      writer.uint32(34).string(message.audioRequestString);
    }
    if (message.tapName !== "") {
      writer.uint32(42).string(message.tapName);
    }
    if (message.volume !== 0) {
      writer.uint32(53).float(message.volume);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Track {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrack();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.trackId = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.queueName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.audioRequestString = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.tapName = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 53) {
            break;
          }

          message.volume = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Track {
    return {
      trackId: isSet(object.trackId) ? globalThis.Number(object.trackId) : 0,
      queueName: isSet(object.queueName) ? globalThis.String(object.queueName) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      audioRequestString: isSet(object.audioRequestString) ? globalThis.String(object.audioRequestString) : "",
      tapName: isSet(object.tapName) ? globalThis.String(object.tapName) : "",
      volume: isSet(object.volume) ? globalThis.Number(object.volume) : 0,
    };
  },

  toJSON(message: Track): unknown {
    const obj: any = {};
    if (message.trackId !== 0) {
      obj.trackId = Math.round(message.trackId);
    }
    if (message.queueName !== "") {
      obj.queueName = message.queueName;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.audioRequestString !== "") {
      obj.audioRequestString = message.audioRequestString;
    }
    if (message.tapName !== "") {
      obj.tapName = message.tapName;
    }
    if (message.volume !== 0) {
      obj.volume = message.volume;
    }
    return obj;
  },

  create(base?: DeepPartial<Track>): Track {
    return Track.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Track>): Track {
    const message = createBaseTrack();
    message.trackId = object.trackId ?? 0;
    message.queueName = object.queueName ?? "";
    message.description = object.description ?? "";
    message.audioRequestString = object.audioRequestString ?? "";
    message.tapName = object.tapName ?? "";
    message.volume = object.volume ?? 0;
    return message;
  },
};

function createBaseGetSessionStateRequest(): GetSessionStateRequest {
  return { guildId: 0 };
}

export const GetSessionStateRequest: MessageFns<GetSessionStateRequest> = {
  encode(message: GetSessionStateRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.guildId !== 0) {
      writer.uint32(8).uint64(message.guildId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSessionStateRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSessionStateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.guildId = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSessionStateRequest {
    return { guildId: isSet(object.guildId) ? globalThis.Number(object.guildId) : 0 };
  },

  toJSON(message: GetSessionStateRequest): unknown {
    const obj: any = {};
    if (message.guildId !== 0) {
      obj.guildId = Math.round(message.guildId);
    }
    return obj;
  },

  create(base?: DeepPartial<GetSessionStateRequest>): GetSessionStateRequest {
    return GetSessionStateRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetSessionStateRequest>): GetSessionStateRequest {
    const message = createBaseGetSessionStateRequest();
    message.guildId = object.guildId ?? 0;
    return message;
  },
};

function createBaseSessionState(): SessionState {
  return { guildId: 0, channelId: 0, tracks: [] };
}

export const SessionState: MessageFns<SessionState> = {
  encode(message: SessionState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.guildId !== 0) {
      writer.uint32(8).uint64(message.guildId);
    }
    if (message.channelId !== 0) {
      writer.uint32(16).uint64(message.channelId);
    }
    for (const v of message.tracks) {
      Track.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SessionState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSessionState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.guildId = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.channelId = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tracks.push(Track.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SessionState {
    return {
      guildId: isSet(object.guildId) ? globalThis.Number(object.guildId) : 0,
      channelId: isSet(object.channelId) ? globalThis.Number(object.channelId) : 0,
      tracks: globalThis.Array.isArray(object?.tracks) ? object.tracks.map((e: any) => Track.fromJSON(e)) : [],
    };
  },

  toJSON(message: SessionState): unknown {
    const obj: any = {};
    if (message.guildId !== 0) {
      obj.guildId = Math.round(message.guildId);
    }
    if (message.channelId !== 0) {
      obj.channelId = Math.round(message.channelId);
    }
    if (message.tracks?.length) {
      obj.tracks = message.tracks.map((e) => Track.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<SessionState>): SessionState {
    return SessionState.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SessionState>): SessionState {
    const message = createBaseSessionState();
    message.guildId = object.guildId ?? 0;
    message.channelId = object.channelId ?? 0;
    message.tracks = object.tracks?.map((e) => Track.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSessionStateResponse(): SessionStateResponse {
  return { state: undefined, error: undefined };
}

export const SessionStateResponse: MessageFns<SessionStateResponse> = {
  encode(message: SessionStateResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.state !== undefined) {
      SessionState.encode(message.state, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SessionStateResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSessionStateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.state = SessionState.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SessionStateResponse {
    return {
      state: isSet(object.state) ? SessionState.fromJSON(object.state) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: SessionStateResponse): unknown {
    const obj: any = {};
    if (message.state !== undefined) {
      obj.state = SessionState.toJSON(message.state);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    return obj;
  },

  create(base?: DeepPartial<SessionStateResponse>): SessionStateResponse {
    return SessionStateResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SessionStateResponse>): SessionStateResponse {
    const message = createBaseSessionStateResponse();
    message.state = (object.state !== undefined && object.state !== null)
      ? SessionState.fromPartial(object.state)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    return message;
  },
};

function createBaseJoinRequest(): JoinRequest {
  return { guildId: 0, channelId: 0 };
}

export const JoinRequest: MessageFns<JoinRequest> = {
  encode(message: JoinRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.guildId !== 0) {
      writer.uint32(8).uint64(message.guildId);
    }
    if (message.channelId !== 0) {
      writer.uint32(16).uint64(message.channelId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JoinRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJoinRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.guildId = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.channelId = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JoinRequest {
    return {
      guildId: isSet(object.guildId) ? globalThis.Number(object.guildId) : 0,
      channelId: isSet(object.channelId) ? globalThis.Number(object.channelId) : 0,
    };
  },

  toJSON(message: JoinRequest): unknown {
    const obj: any = {};
    if (message.guildId !== 0) {
      obj.guildId = Math.round(message.guildId);
    }
    if (message.channelId !== 0) {
      obj.channelId = Math.round(message.channelId);
    }
    return obj;
  },

  create(base?: DeepPartial<JoinRequest>): JoinRequest {
    return JoinRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<JoinRequest>): JoinRequest {
    const message = createBaseJoinRequest();
    message.guildId = object.guildId ?? 0;
    message.channelId = object.channelId ?? 0;
    return message;
  },
};

function createBaseLeaveRequest(): LeaveRequest {
  return { guildId: 0 };
}

export const LeaveRequest: MessageFns<LeaveRequest> = {
  encode(message: LeaveRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.guildId !== 0) {
      writer.uint32(8).uint64(message.guildId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LeaveRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLeaveRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.guildId = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LeaveRequest {
    return { guildId: isSet(object.guildId) ? globalThis.Number(object.guildId) : 0 };
  },

  toJSON(message: LeaveRequest): unknown {
    const obj: any = {};
    if (message.guildId !== 0) {
      obj.guildId = Math.round(message.guildId);
    }
    return obj;
  },

  create(base?: DeepPartial<LeaveRequest>): LeaveRequest {
    return LeaveRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LeaveRequest>): LeaveRequest {
    const message = createBaseLeaveRequest();
    message.guildId = object.guildId ?? 0;
    return message;
  },
};

function createBaseAudioStopFilter(): AudioStopFilter {
  return { all: undefined, music: undefined, tts: undefined };
}

export const AudioStopFilter: MessageFns<AudioStopFilter> = {
  encode(message: AudioStopFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.all !== undefined) {
      AudioStopFilter_All.encode(message.all, writer.uint32(10).fork()).join();
    }
    if (message.music !== undefined) {
      AudioStopFilter_Music.encode(message.music, writer.uint32(18).fork()).join();
    }
    if (message.tts !== undefined) {
      AudioStopFilter_TTS.encode(message.tts, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AudioStopFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAudioStopFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.all = AudioStopFilter_All.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.music = AudioStopFilter_Music.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tts = AudioStopFilter_TTS.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AudioStopFilter {
    return {
      all: isSet(object.all) ? AudioStopFilter_All.fromJSON(object.all) : undefined,
      music: isSet(object.music) ? AudioStopFilter_Music.fromJSON(object.music) : undefined,
      tts: isSet(object.tts) ? AudioStopFilter_TTS.fromJSON(object.tts) : undefined,
    };
  },

  toJSON(message: AudioStopFilter): unknown {
    const obj: any = {};
    if (message.all !== undefined) {
      obj.all = AudioStopFilter_All.toJSON(message.all);
    }
    if (message.music !== undefined) {
      obj.music = AudioStopFilter_Music.toJSON(message.music);
    }
    if (message.tts !== undefined) {
      obj.tts = AudioStopFilter_TTS.toJSON(message.tts);
    }
    return obj;
  },

  create(base?: DeepPartial<AudioStopFilter>): AudioStopFilter {
    return AudioStopFilter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AudioStopFilter>): AudioStopFilter {
    const message = createBaseAudioStopFilter();
    message.all = (object.all !== undefined && object.all !== null)
      ? AudioStopFilter_All.fromPartial(object.all)
      : undefined;
    message.music = (object.music !== undefined && object.music !== null)
      ? AudioStopFilter_Music.fromPartial(object.music)
      : undefined;
    message.tts = (object.tts !== undefined && object.tts !== null)
      ? AudioStopFilter_TTS.fromPartial(object.tts)
      : undefined;
    return message;
  },
};

function createBaseAudioStopFilter_All(): AudioStopFilter_All {
  return {};
}

export const AudioStopFilter_All: MessageFns<AudioStopFilter_All> = {
  encode(_: AudioStopFilter_All, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AudioStopFilter_All {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAudioStopFilter_All();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): AudioStopFilter_All {
    return {};
  },

  toJSON(_: AudioStopFilter_All): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<AudioStopFilter_All>): AudioStopFilter_All {
    return AudioStopFilter_All.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<AudioStopFilter_All>): AudioStopFilter_All {
    const message = createBaseAudioStopFilter_All();
    return message;
  },
};

function createBaseAudioStopFilter_Music(): AudioStopFilter_Music {
  return {};
}

export const AudioStopFilter_Music: MessageFns<AudioStopFilter_Music> = {
  encode(_: AudioStopFilter_Music, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AudioStopFilter_Music {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAudioStopFilter_Music();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): AudioStopFilter_Music {
    return {};
  },

  toJSON(_: AudioStopFilter_Music): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<AudioStopFilter_Music>): AudioStopFilter_Music {
    return AudioStopFilter_Music.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<AudioStopFilter_Music>): AudioStopFilter_Music {
    const message = createBaseAudioStopFilter_Music();
    return message;
  },
};

function createBaseAudioStopFilter_TTS(): AudioStopFilter_TTS {
  return { userId: 0 };
}

export const AudioStopFilter_TTS: MessageFns<AudioStopFilter_TTS> = {
  encode(message: AudioStopFilter_TTS, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== 0) {
      writer.uint32(8).uint64(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AudioStopFilter_TTS {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAudioStopFilter_TTS();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userId = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AudioStopFilter_TTS {
    return { userId: isSet(object.userId) ? globalThis.Number(object.userId) : 0 };
  },

  toJSON(message: AudioStopFilter_TTS): unknown {
    const obj: any = {};
    if (message.userId !== 0) {
      obj.userId = Math.round(message.userId);
    }
    return obj;
  },

  create(base?: DeepPartial<AudioStopFilter_TTS>): AudioStopFilter_TTS {
    return AudioStopFilter_TTS.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AudioStopFilter_TTS>): AudioStopFilter_TTS {
    const message = createBaseAudioStopFilter_TTS();
    message.userId = object.userId ?? 0;
    return message;
  },
};

function createBaseError(): Error {
  return { message: "", isInternal: false };
}

export const Error: MessageFns<Error> = {
  encode(message: Error, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    if (message.isInternal !== false) {
      writer.uint32(16).bool(message.isInternal);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Error {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.isInternal = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Error {
    return {
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      isInternal: isSet(object.isInternal) ? globalThis.Boolean(object.isInternal) : false,
    };
  },

  toJSON(message: Error): unknown {
    const obj: any = {};
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.isInternal !== false) {
      obj.isInternal = message.isInternal;
    }
    return obj;
  },

  create(base?: DeepPartial<Error>): Error {
    return Error.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Error>): Error {
    const message = createBaseError();
    message.message = object.message ?? "";
    message.isInternal = object.isInternal ?? false;
    return message;
  },
};

function createBaseOkResponse(): OkResponse {
  return { success: undefined, error: undefined };
}

export const OkResponse: MessageFns<OkResponse> = {
  encode(message: OkResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== undefined) {
      writer.uint32(8).bool(message.success);
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OkResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOkResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OkResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: OkResponse): unknown {
    const obj: any = {};
    if (message.success !== undefined) {
      obj.success = message.success;
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    return obj;
  },

  create(base?: DeepPartial<OkResponse>): OkResponse {
    return OkResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OkResponse>): OkResponse {
    const message = createBaseOkResponse();
    message.success = object.success ?? undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    return message;
  },
};

function createBasePlayRequest(): PlayRequest {
  return { guildId: 0, queueName: "", tapName: "", audioRequestString: "", volume: 0 };
}

export const PlayRequest: MessageFns<PlayRequest> = {
  encode(message: PlayRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.guildId !== 0) {
      writer.uint32(8).uint64(message.guildId);
    }
    if (message.queueName !== "") {
      writer.uint32(18).string(message.queueName);
    }
    if (message.tapName !== "") {
      writer.uint32(26).string(message.tapName);
    }
    if (message.audioRequestString !== "") {
      writer.uint32(34).string(message.audioRequestString);
    }
    if (message.volume !== 0) {
      writer.uint32(45).float(message.volume);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlayRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlayRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.guildId = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.queueName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tapName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.audioRequestString = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 45) {
            break;
          }

          message.volume = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlayRequest {
    return {
      guildId: isSet(object.guildId) ? globalThis.Number(object.guildId) : 0,
      queueName: isSet(object.queueName) ? globalThis.String(object.queueName) : "",
      tapName: isSet(object.tapName) ? globalThis.String(object.tapName) : "",
      audioRequestString: isSet(object.audioRequestString) ? globalThis.String(object.audioRequestString) : "",
      volume: isSet(object.volume) ? globalThis.Number(object.volume) : 0,
    };
  },

  toJSON(message: PlayRequest): unknown {
    const obj: any = {};
    if (message.guildId !== 0) {
      obj.guildId = Math.round(message.guildId);
    }
    if (message.queueName !== "") {
      obj.queueName = message.queueName;
    }
    if (message.tapName !== "") {
      obj.tapName = message.tapName;
    }
    if (message.audioRequestString !== "") {
      obj.audioRequestString = message.audioRequestString;
    }
    if (message.volume !== 0) {
      obj.volume = message.volume;
    }
    return obj;
  },

  create(base?: DeepPartial<PlayRequest>): PlayRequest {
    return PlayRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PlayRequest>): PlayRequest {
    const message = createBasePlayRequest();
    message.guildId = object.guildId ?? 0;
    message.queueName = object.queueName ?? "";
    message.tapName = object.tapName ?? "";
    message.audioRequestString = object.audioRequestString ?? "";
    message.volume = object.volume ?? 0;
    return message;
  },
};

function createBasePlayResponse(): PlayResponse {
  return { trackId: undefined, error: undefined };
}

export const PlayResponse: MessageFns<PlayResponse> = {
  encode(message: PlayResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.trackId !== undefined) {
      writer.uint32(8).uint64(message.trackId);
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlayResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlayResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.trackId = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlayResponse {
    return {
      trackId: isSet(object.trackId) ? globalThis.Number(object.trackId) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: PlayResponse): unknown {
    const obj: any = {};
    if (message.trackId !== undefined) {
      obj.trackId = Math.round(message.trackId);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    return obj;
  },

  create(base?: DeepPartial<PlayResponse>): PlayResponse {
    return PlayResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PlayResponse>): PlayResponse {
    const message = createBasePlayResponse();
    message.trackId = object.trackId ?? undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    return message;
  },
};

function createBaseSetVolumeRequest(): SetVolumeRequest {
  return { guildId: 0, trackId: 0, volume: 0 };
}

export const SetVolumeRequest: MessageFns<SetVolumeRequest> = {
  encode(message: SetVolumeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.guildId !== 0) {
      writer.uint32(8).uint64(message.guildId);
    }
    if (message.trackId !== 0) {
      writer.uint32(16).uint64(message.trackId);
    }
    if (message.volume !== 0) {
      writer.uint32(29).float(message.volume);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetVolumeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetVolumeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.guildId = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.trackId = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.volume = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetVolumeRequest {
    return {
      guildId: isSet(object.guildId) ? globalThis.Number(object.guildId) : 0,
      trackId: isSet(object.trackId) ? globalThis.Number(object.trackId) : 0,
      volume: isSet(object.volume) ? globalThis.Number(object.volume) : 0,
    };
  },

  toJSON(message: SetVolumeRequest): unknown {
    const obj: any = {};
    if (message.guildId !== 0) {
      obj.guildId = Math.round(message.guildId);
    }
    if (message.trackId !== 0) {
      obj.trackId = Math.round(message.trackId);
    }
    if (message.volume !== 0) {
      obj.volume = message.volume;
    }
    return obj;
  },

  create(base?: DeepPartial<SetVolumeRequest>): SetVolumeRequest {
    return SetVolumeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SetVolumeRequest>): SetVolumeRequest {
    const message = createBaseSetVolumeRequest();
    message.guildId = object.guildId ?? 0;
    message.trackId = object.trackId ?? 0;
    message.volume = object.volume ?? 0;
    return message;
  },
};

function createBaseStopRequest(): StopRequest {
  return { guildId: 0, trackId: "" };
}

export const StopRequest: MessageFns<StopRequest> = {
  encode(message: StopRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.guildId !== 0) {
      writer.uint32(8).uint64(message.guildId);
    }
    if (message.trackId !== "") {
      writer.uint32(18).string(message.trackId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StopRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStopRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.guildId = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.trackId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StopRequest {
    return {
      guildId: isSet(object.guildId) ? globalThis.Number(object.guildId) : 0,
      trackId: isSet(object.trackId) ? globalThis.String(object.trackId) : "",
    };
  },

  toJSON(message: StopRequest): unknown {
    const obj: any = {};
    if (message.guildId !== 0) {
      obj.guildId = Math.round(message.guildId);
    }
    if (message.trackId !== "") {
      obj.trackId = message.trackId;
    }
    return obj;
  },

  create(base?: DeepPartial<StopRequest>): StopRequest {
    return StopRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StopRequest>): StopRequest {
    const message = createBaseStopRequest();
    message.guildId = object.guildId ?? 0;
    message.trackId = object.trackId ?? "";
    return message;
  },
};

function createBaseNextMusicRequest(): NextMusicRequest {
  return { guildId: 0 };
}

export const NextMusicRequest: MessageFns<NextMusicRequest> = {
  encode(message: NextMusicRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.guildId !== 0) {
      writer.uint32(8).uint64(message.guildId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NextMusicRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNextMusicRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.guildId = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NextMusicRequest {
    return { guildId: isSet(object.guildId) ? globalThis.Number(object.guildId) : 0 };
  },

  toJSON(message: NextMusicRequest): unknown {
    const obj: any = {};
    if (message.guildId !== 0) {
      obj.guildId = Math.round(message.guildId);
    }
    return obj;
  },

  create(base?: DeepPartial<NextMusicRequest>): NextMusicRequest {
    return NextMusicRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NextMusicRequest>): NextMusicRequest {
    const message = createBaseNextMusicRequest();
    message.guildId = object.guildId ?? 0;
    return message;
  },
};

function createBaseStopManyRequest(): StopManyRequest {
  return { guildId: 0, filter: undefined };
}

export const StopManyRequest: MessageFns<StopManyRequest> = {
  encode(message: StopManyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.guildId !== 0) {
      writer.uint32(8).uint64(message.guildId);
    }
    if (message.filter !== undefined) {
      AudioStopFilter.encode(message.filter, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StopManyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStopManyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.guildId = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.filter = AudioStopFilter.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StopManyRequest {
    return {
      guildId: isSet(object.guildId) ? globalThis.Number(object.guildId) : 0,
      filter: isSet(object.filter) ? AudioStopFilter.fromJSON(object.filter) : undefined,
    };
  },

  toJSON(message: StopManyRequest): unknown {
    const obj: any = {};
    if (message.guildId !== 0) {
      obj.guildId = Math.round(message.guildId);
    }
    if (message.filter !== undefined) {
      obj.filter = AudioStopFilter.toJSON(message.filter);
    }
    return obj;
  },

  create(base?: DeepPartial<StopManyRequest>): StopManyRequest {
    return StopManyRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StopManyRequest>): StopManyRequest {
    const message = createBaseStopManyRequest();
    message.guildId = object.guildId ?? 0;
    message.filter = (object.filter !== undefined && object.filter !== null)
      ? AudioStopFilter.fromPartial(object.filter)
      : undefined;
    return message;
  },
};

export type AudioEngineDefinition = typeof AudioEngineDefinition;
export const AudioEngineDefinition = {
  name: "AudioEngine",
  fullName: "audio_engine.AudioEngine",
  methods: {
    join: {
      name: "Join",
      requestType: JoinRequest,
      requestStream: false,
      responseType: OkResponse,
      responseStream: false,
      options: {},
    },
    leave: {
      name: "Leave",
      requestType: LeaveRequest,
      requestStream: false,
      responseType: OkResponse,
      responseStream: false,
      options: {},
    },
    play: {
      name: "Play",
      requestType: PlayRequest,
      requestStream: false,
      responseType: PlayResponse,
      responseStream: false,
      options: {},
    },
    setVolume: {
      name: "SetVolume",
      requestType: SetVolumeRequest,
      requestStream: false,
      responseType: OkResponse,
      responseStream: false,
      options: {},
    },
    stop: {
      name: "Stop",
      requestType: StopRequest,
      requestStream: false,
      responseType: OkResponse,
      responseStream: false,
      options: {},
    },
    stopMany: {
      name: "StopMany",
      requestType: StopManyRequest,
      requestStream: false,
      responseType: OkResponse,
      responseStream: false,
      options: {},
    },
    nextMusic: {
      name: "NextMusic",
      requestType: NextMusicRequest,
      requestStream: false,
      responseType: OkResponse,
      responseStream: false,
      options: {},
    },
    getSessionState: {
      name: "GetSessionState",
      requestType: GetSessionStateRequest,
      requestStream: false,
      responseType: SessionStateResponse,
      responseStream: false,
      options: {},
    },
  },
} as const;

export interface AudioEngineServiceImplementation<CallContextExt = {}> {
  join(request: JoinRequest, context: CallContext & CallContextExt): Promise<DeepPartial<OkResponse>>;
  leave(request: LeaveRequest, context: CallContext & CallContextExt): Promise<DeepPartial<OkResponse>>;
  play(request: PlayRequest, context: CallContext & CallContextExt): Promise<DeepPartial<PlayResponse>>;
  setVolume(request: SetVolumeRequest, context: CallContext & CallContextExt): Promise<DeepPartial<OkResponse>>;
  stop(request: StopRequest, context: CallContext & CallContextExt): Promise<DeepPartial<OkResponse>>;
  stopMany(request: StopManyRequest, context: CallContext & CallContextExt): Promise<DeepPartial<OkResponse>>;
  nextMusic(request: NextMusicRequest, context: CallContext & CallContextExt): Promise<DeepPartial<OkResponse>>;
  getSessionState(
    request: GetSessionStateRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<SessionStateResponse>>;
}

export interface AudioEngineClient<CallOptionsExt = {}> {
  join(request: DeepPartial<JoinRequest>, options?: CallOptions & CallOptionsExt): Promise<OkResponse>;
  leave(request: DeepPartial<LeaveRequest>, options?: CallOptions & CallOptionsExt): Promise<OkResponse>;
  play(request: DeepPartial<PlayRequest>, options?: CallOptions & CallOptionsExt): Promise<PlayResponse>;
  setVolume(request: DeepPartial<SetVolumeRequest>, options?: CallOptions & CallOptionsExt): Promise<OkResponse>;
  stop(request: DeepPartial<StopRequest>, options?: CallOptions & CallOptionsExt): Promise<OkResponse>;
  stopMany(request: DeepPartial<StopManyRequest>, options?: CallOptions & CallOptionsExt): Promise<OkResponse>;
  nextMusic(request: DeepPartial<NextMusicRequest>, options?: CallOptions & CallOptionsExt): Promise<OkResponse>;
  getSessionState(
    request: DeepPartial<GetSessionStateRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<SessionStateResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
